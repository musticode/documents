# Algorithms


By mastering these 21 DSA patterns


1. Fast and Slow Pointer

* Cycle detection method
* O(1) space efficiency
* Linked list problems


2. Merge Intervals

* Sort and merge
* O(n log n) complexity
* Overlapping interval handling


3. Sliding Window

* Fixed/variable window
* O(n) time optimization
* Subarray/substring problems


4. Islands (Matrix Traversal)

* DFS/BFS traversal
* Connected component detection
* 2D grid problems


5. Two Pointers

* Dual pointer strategy
* Linear time complexity
* Array/list problems


6. Cyclic Sort

* Sorting in cycles
* O(n) time complexity
* Constant space usage


7. In-place Reversal of Linked List

* Reverse without extra space
* O(n) time efficiency
* Pointer manipulation technique


8. Breadth First Search

* Level-by-level traversal
* Uses queue structure
* Shortest path problems


9. Depth First Search

* Recursive/backtracking approach
* Uses stack (or recursion)
* Tree/graph traversal


10. Two Heaps

* Max and min heaps
* Median tracking efficiently
* O(log n) insertions


11. Subsets

* Generate all subsets
* Recursive or iterative
* Backtracking or bitmasking


12. Modified Binary Search

* Search in variations
* O(log n) time
* Rotated/specialized arrays


13. Bitwise XOR

* Toggle bits operation
* O(1) space complexity
* Efficient for pairing


14. Top 'K' elements

* Use heap/quickselect
* O(n log k) time
* Efficient selection problem


15. K-way Merge

* Merge sorted lists
* Min-heap based approach
* O(n log k) complexity


16. 0/1 Knapsack (Dynamic Programming)

* Choose or skip items
* O(n \* W) complexity
* Maximize value selection


17. Unbounded Knapsack (Dynamic Programming)

* Unlimited item choices
* O(n \* W) complexity
* Multiple item selection


18. Topological Sort (Graphs)

* Directed acyclic graph
* Order dependency resolution
* Uses DFS or BFS


19. Monotonic Stack

* Maintain increasing/decreasing stack
* Optimized for range queries
* O(n) time complexity


20. Backtracking

* Recursive decision-making
* Explore all possibilities
* Pruning with constraints


21. Greedy Algorithm

* Make locally optimal choices
* Efficient for problems with optimal substructure
* Covers tasks like activity selection, minimum coins


## Graph Algorithms

If you want to master Graphs for coding interviews, learn these 10 algorithms:


 1. 𝐃𝐞𝐩𝐭𝐡 𝐅𝐢𝐫𝐬𝐭 𝐒𝐞𝐚𝐫𝐜𝐡 (𝐃𝐅𝐒): Explores as far as possible along each branch of a node before backtracking. Useful to explore all possible paths, detecting cycles, and finding connected components.
 2. 𝐁𝐫𝐞𝐚𝐝𝐭𝐡 𝐅𝐢𝐫𝐬𝐭 𝐒𝐞𝐚𝐫𝐜𝐡 (𝐁𝐅𝐒): Explores all neighbors at the present depth before moving to nodes at the next depth level. Perfect for finding the shortest path in unweighted graphs and solving problems that involve level-order traversal.
 3. 𝐓𝐨𝐩𝐨𝐥𝐨𝐠𝐢𝐜𝐚𝐥 𝐒𝐨𝐫𝐭: Orders vertices in a directed acyclic graph (DAG) such that for every edge (u -> v), u comes before v. Useful for scheduling problems like course prerequisites or build orders.
 4. 𝐔𝐧𝐢𝐨𝐧 𝐅𝐢𝐧𝐝 (𝐃𝐢𝐬𝐣𝐨𝐢𝐧𝐭 𝐒𝐞𝐭): Tracks a set of elements partitioned into disjoint subsets. Useful for detecting cycles in undirected graphs and implementing other graph algorithms like Kruskal’s MST algorithm.
 5. 𝐂𝐲𝐜𝐥𝐞 𝐃𝐞𝐭𝐞𝐜𝐭𝐢𝐨𝐧: Uses DFS/BFS to identify cycles in a graph. Useful to avoid infinite loops and detecting deadlocks.
 6. 𝐂𝐨𝐧𝐧𝐞𝐜𝐭𝐞𝐝 𝐂𝐨𝐦𝐩𝐨𝐧𝐞𝐧𝐭𝐬: Used to identify subgraphs in a graph where every vertex is reachable from every other vertex.
 7. 𝐁𝐢𝐩𝐚𝐫𝐭𝐢𝐭𝐞 𝐆𝐫𝐚𝐩𝐡: Checks if a graph can be divided into two sets of vertices with no edges within the same set. Useful to solve problems that involve two-coloring, matching, and partitioning.
 8. 𝐅𝐥𝐨𝐨𝐝 𝐅𝐢𝐥𝐥: Explores and colors connected cells in a 2D array. Useful to solve grid-based problems like finding the number of islands.
 9. 𝐌𝐢𝐧𝐢𝐦𝐮𝐦 𝐒𝐩𝐚𝐧𝐧𝐢𝐧𝐠 𝐓𝐫𝐞𝐞 (𝐌𝐒𝐓): Used to find a subset of edges that connects all vertices with minimum total edge weight. Prim's and Kruskal's are two well-known algorithms for finding MST.
10. 𝐒𝐡𝐨𝐫𝐭𝐞𝐬𝐭 𝐏𝐚𝐭𝐡: Used to find the shortest path with minimum weight from one vertex to other vertices in a graph. Dijkstra’s and Bellman-Ford are two popular algorithms.

If you want to learn about these algorithms in detail, checkout this article: <https://blog.algomaster.io/p/master-graph-algorithms-for-coding>