# Algorithms


By mastering these 21 DSA patterns


1. Fast and Slow Pointer

* Cycle detection method
* O(1) space efficiency
* Linked list problems


2. Merge Intervals

* Sort and merge
* O(n log n) complexity
* Overlapping interval handling


3. Sliding Window

* Fixed/variable window
* O(n) time optimization
* Subarray/substring problems


4. Islands (Matrix Traversal)

* DFS/BFS traversal
* Connected component detection
* 2D grid problems


5. Two Pointers

* Dual pointer strategy
* Linear time complexity
* Array/list problems


6. Cyclic Sort

* Sorting in cycles
* O(n) time complexity
* Constant space usage


7. In-place Reversal of Linked List

* Reverse without extra space
* O(n) time efficiency
* Pointer manipulation technique


8. Breadth First Search

* Level-by-level traversal
* Uses queue structure
* Shortest path problems


9. Depth First Search

* Recursive/backtracking approach
* Uses stack (or recursion)
* Tree/graph traversal


10. Two Heaps

* Max and min heaps
* Median tracking efficiently
* O(log n) insertions


11. Subsets

* Generate all subsets
* Recursive or iterative
* Backtracking or bitmasking


12. Modified Binary Search

* Search in variations
* O(log n) time
* Rotated/specialized arrays


13. Bitwise XOR

* Toggle bits operation
* O(1) space complexity
* Efficient for pairing


14. Top 'K' elements

* Use heap/quickselect
* O(n log k) time
* Efficient selection problem


15. K-way Merge

* Merge sorted lists
* Min-heap based approach
* O(n log k) complexity


16. 0/1 Knapsack (Dynamic Programming)

* Choose or skip items
* O(n \* W) complexity
* Maximize value selection


17. Unbounded Knapsack (Dynamic Programming)

* Unlimited item choices
* O(n \* W) complexity
* Multiple item selection


18. Topological Sort (Graphs)

* Directed acyclic graph
* Order dependency resolution
* Uses DFS or BFS


19. Monotonic Stack

* Maintain increasing/decreasing stack
* Optimized for range queries
* O(n) time complexity


20. Backtracking

* Recursive decision-making
* Explore all possibilities
* Pruning with constraints


21. Greedy Algorithm

* Make locally optimal choices
* Efficient for problems with optimal substructure
* Covers tasks like activity selection, minimum coins


## Graph Algorithms

If you want to master Graphs for coding interviews, learn these 10 algorithms:


 1. ğƒğğ©ğ­ğ¡ ğ…ğ¢ğ«ğ¬ğ­ ğ’ğğšğ«ğœğ¡ (ğƒğ…ğ’): Explores as far as possible along each branch of a node before backtracking. Useful to explore all possible paths, detecting cycles, and finding connected components.
 2. ğğ«ğğšğğ­ğ¡ ğ…ğ¢ğ«ğ¬ğ­ ğ’ğğšğ«ğœğ¡ (ğğ…ğ’): Explores all neighbors at the present depth before moving to nodes at the next depth level. Perfect for finding the shortest path in unweighted graphs and solving problems that involve level-order traversal.
 3. ğ“ğ¨ğ©ğ¨ğ¥ğ¨ğ ğ¢ğœğšğ¥ ğ’ğ¨ğ«ğ­: Orders vertices in a directed acyclic graph (DAG) such that for every edge (u -> v), u comes before v. Useful for scheduling problems like course prerequisites or build orders.
 4. ğ”ğ§ğ¢ğ¨ğ§ ğ…ğ¢ğ§ğ (ğƒğ¢ğ¬ğ£ğ¨ğ¢ğ§ğ­ ğ’ğğ­): Tracks a set of elements partitioned into disjoint subsets. Useful for detecting cycles in undirected graphs and implementing other graph algorithms like Kruskalâ€™s MST algorithm.
 5. ğ‚ğ²ğœğ¥ğ ğƒğğ­ğğœğ­ğ¢ğ¨ğ§: Uses DFS/BFS to identify cycles in a graph. Useful to avoid infinite loops and detecting deadlocks.
 6. ğ‚ğ¨ğ§ğ§ğğœğ­ğğ ğ‚ğ¨ğ¦ğ©ğ¨ğ§ğğ§ğ­ğ¬: Used to identify subgraphs in a graph where every vertex is reachable from every other vertex.
 7. ğğ¢ğ©ğšğ«ğ­ğ¢ğ­ğ ğ†ğ«ğšğ©ğ¡: Checks if a graph can be divided into two sets of vertices with no edges within the same set. Useful to solve problems that involve two-coloring, matching, and partitioning.
 8. ğ…ğ¥ğ¨ğ¨ğ ğ…ğ¢ğ¥ğ¥: Explores and colors connected cells in a 2D array. Useful to solve grid-based problems like finding the number of islands.
 9. ğŒğ¢ğ§ğ¢ğ¦ğ®ğ¦ ğ’ğ©ğšğ§ğ§ğ¢ğ§ğ  ğ“ğ«ğğ (ğŒğ’ğ“): Used to find a subset of edges that connects all vertices with minimum total edge weight. Prim's and Kruskal's are two well-known algorithms for finding MST.
10. ğ’ğ¡ğ¨ğ«ğ­ğğ¬ğ­ ğğšğ­ğ¡: Used to find the shortest path with minimum weight from one vertex to other vertices in a graph. Dijkstraâ€™s and Bellman-Ford are two popular algorithms.

If you want to learn about these algorithms in detail, checkout this article: <https://blog.algomaster.io/p/master-graph-algorithms-for-coding>